% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fozzie_join.R
\name{fozzie_join}
\alias{fozzie_join}
\title{Perform a fuzzy join between two data frames using approximate string matching.}
\usage{
fozzie_join(
  df1,
  df2,
  by,
  method = "levenshtein",
  how = "inner",
  max_distance = 1,
  distance_col = NULL,
  q = NULL,
  max_prefix = 0,
  prefix_weight = 0,
  nthread = NULL
)
}
\arguments{
\item{df1}{A data frame containing the first dataset.}

\item{df2}{A data frame containing the second dataset.}

\item{by}{A named vector specifying the columns to join on.
\itemize{
\item \code{names(by)[1]}: Column name in \code{df1}.
\item \code{names(by)[2]}: Corresponding column name in \code{df2}.
}}

\item{method}{String specifying the fuzzy matching algorithm to use. Options include:
\itemize{
\item \code{"levenshtein"} (default) - Standard Levenshtein edit distance.
\item \code{"osa"} - Optimal string alignment distance.
\item \code{"damerau_levensthein"} or \code{"dl"} - Damerau-Levenshtein edit distance.
\item \code{"hamming"} - Hamming distance (only works for equal-length strings).
\item \code{"lcs"} - Longest common subsequence.
\item \code{"qgram"} - Q-gram similarity (requires \code{q} parameter).
\item \code{"cosine"} - Cosine similarity (requires \code{q} parameter).
\item \code{"jaccard"} - Jaccard similarity (requires \code{q} parameter).
\item \code{"jaro_winkler"} or \code{"jw"} - Jaro-Winkler similarity.
\item \code{"jaro"} - Standard Jaro similarity.
}}

\item{how}{A string specifying the type of join to perform (\code{"inner"}, \code{"left"}, \code{"right"}, or \code{"full"}).
\itemize{
\item \code{"inner"} (default): Returns only matches.
\item \code{"left"}: Returns all rows from \code{df1}, with matches from \code{df2}.
\item \code{"right"}: Returns all rows from \code{df2}, with matches from \code{df1}.
\item \code{"full"}: \link{Not implemented} Returns all rows from both \code{df1} and \code{df2}, matching where possible.
\item \code{"anti"}: \link{Not implemented} Returns all rows from \code{df1} not in \code{df2}.
}}

\item{max_distance}{Numeric value specifying the maximum allowable edit distance for a match.}

\item{distance_col}{Optional column name as a string to store the computed distance values in the output.
If \code{NULL}, distances will not be included in the output.}

\item{q}{Integer specifying the \emph{q}-gram size (only required for \code{"qgram"}, \code{"cosine"}, and \code{"jaccard"} methods).
If \code{NULL}, an error will be raised for these methods.}

\item{max_prefix}{For Jaro-Winkler edit distance, the max prefix size in characters (default is \code{0}).}

\item{prefix_weight}{For Jaro-Winkler edit distance, the adjustment factor for shared prefixes. The default must not be higher than the reciprocal of max_prefix (deafult is \code{0}).}
}
\value{
A data frame containing matched records from \code{df1} and \code{df2},
with column names suffixed as \code{.x} (from \code{df1}) and \code{.y} (from \code{df2}).
If \code{distance_col} is provided, the computed distance values will be included.
}
\description{
This function matches records in \code{df1} and \code{df2} based on a specified column,
allowing fuzzy matches within a given distance threshold. It supports various
approximate matching methods including Levenshtein, Damerau-Levenshtein, Jaro-Winkler, and more.
}
\examples{
df1 <- data.frame(Name = c("Alice", "Bob", "Charlie"))
df2 <- data.frame(Name = c("Alicia", "Robert", "Charles"))
result <- fozzie_join(df1, df2, by = list(Name = "Name"), method = "levenshtein", max_distance = 2, how = "inner", distance_col = "dist")
print(result)

}
